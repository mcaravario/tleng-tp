\section{Gramática}
\label{sec:gramatica}

\subsection{Simbolos Terminales}
	Los símbolos terminales de la gramática son los definidos en el archivo 
	\textit{tokens.py} (Ver sección \ref{codigo:tokens}).

\subsection{Producciones}
	Las producciones de la gramatica son las siguientes. Los terminales
	están puestos en negrita y los no terminales en mayúscula.
% TOKENS
\newToken{\COMMENT}{comment}
\newToken{\SEMICOLON}{;}
\newToken{\ID}{id}
\newToken{\NUMBER}{num}
\newToken{\STRING}{str}
\newToken{\TRUE}{true}
\newToken{\FALSE}{false}
\newToken{\RES}{res}
\newToken{\DOT}{.}
\newToken{\LPARENT}{(}
\newToken{\RPARENT}{)}
\newToken{\LBRACKET}{[}
\newToken{\RBRACKET}{]}
\newToken{\LBRACE}{\{}
\newToken{\RBRACE}{\}}
\newToken{\MULTESCALAR}{multiplicacionEscalar}
\newToken{\CAPITALIZAR}{capitalizar}
\newToken{\COLINEALES}{colineales}
\newToken{\PRINT}{print}
\newToken{\LENGTH}{length}
\newToken{\ADD}{+}
\newToken{\MULT}{*}
\newToken{\COMMA}{,}
\newToken{\IF}{if}
\newToken{\ELSE}{else}
\newToken{\WHILE}{while}
\newToken{\FOR}{for}
\newToken{\DO}{do}
\newToken{\SUB}{-}
\newToken{\DIV}{/}
\newToken{\COLON}{:}
\newToken{\RETURN}{return}
\newToken{\LAMBDA}{$\lambda$}
\newToken{\QUESTION}{?}
\newToken{\AND}{AND}
\newToken{\OR}{OR}
\newToken{\NOT}{NOT}
\newToken{\LEQ}{$<=$}
\newToken{\LT}{$<$}
\newToken{\GEQ}{$>=$}
\newToken{\GT}{$>$}
\newToken{\LNOTEQ}{!=}
\newToken{\EQUAL}{==}
\newToken{\MOD}{\%}
\newToken{\POW}{\^}
\newToken{\INC}{++}
\newToken{\DEC}{--}


% REGLAS
\subsubsection{Instrucciones}
  \begin{reglas}
	  \regla{INSTRLIST}{INSTAUX}
	  \aregla{INSTAUX INSTRLIST}
    \\	
    \regla{INSTR}{COMMENTLIST}
	  \aregla{INSTROP}
	  \aregla{MAYBECOMMENT}
	  \\
    \regla{COMMENTLIST}{\COMMENT COMMENTLIST}
    \aregla{\LAMBDA}
    \\
    \regla{MAYBECOMMENT}{COMMENT}
    \aregla{\LAMBDA}
    \\
    \regla{INSTROP}{ASSIGN \SEMICOLON}
    \aregla{UNARYMOD \SEMICOLON}
    \aregla{CALL \SEMICOLON}
    \aregla{\RETURN EXPRESSION \SEMICOLON}
    \aregla{LOOP}
    \\
    \regla{INSTROPFOR}{ASSIGN}
    \aregla{UNARYMOD}
    \aregla{CALL}
    \aregla{\LAMBDA}
  \end{reglas}

\subsubsection{Bloques de código}
  \begin{reglas}
	  \regla{BLOCK}{INSTR}
	  \aregla{\LBRACE INSTRLIST \RBRACE}
    \\
    \regla{BLOCKAUX}{INSTROP}
	  \aregla{\LBRACE INSTRLIST \RBRACE}
  \end{reglas}

\subsubsection{Condicionales y Ciclos}
  \begin{reglas}
	  \regla{INSTAUX}{MCONDITIONAL}
    \aregla{OCONDITIONAL}
	  \\
    \regla{MCONDITIONAL}{\IF \LPARENT EXPRESSION \RPARENT MCONDITIONAL \ELSE MCONDITIONAL}
    \aregla{BLOCK}
    \\
    \regla{OCONDITIONAL}{\IF \LPARENT EXPRESSION \RPARENT MCONDITIONAL \ELSE OCONDITIONAL}
	  \aregla{\IF \LPARENT EXPRESSION \RPARENT INSTAUX}
    \\
    \regla{LOOP}{\FOR \LPARENT INSTROPFOR \SEMICOLON EXPRESSION \SEMICOLON
    INSTROPFOR \RPARENT BLOCKAUX}
    \aregla{\WHILE \LPARENT EXPRESSION \RPARENT BLOCKAUX}
    \aregla{\DO BLOCK \WHILE \LPARENT EXPRESSION \RPARENT \SEMICOLON}
  \end{reglas}

\subsubsection{Asignaciones y llamadas a funciones}
  \begin{reglas}
	  \regla{ASSIGNOP}{ADDEQ}
    \aregla{SUBEQ}
    \aregla{DIVEQ}
    \aregla{MULTEQ}
	  \\
	  \regla{ASSIGN}{\ID ASSIGNOP EXPRESSION}
    \aregla{ARRAYMEMBER ASSIGNOP EXPRESSION}
    \aregla{REGISTERMEMBER ASSIGNOP EXPRESSION}
	  \\
	  \regla{CALL}{\MULTESCALAR \LPARENT EXPRESSIONLIST \RPARENT}
    \aregla{\CAPITALIZAR \LPARENT EXPRESSIONLIST \RPARENT}
    \aregla{\COLINEALES \LPARENT EXPRESSIONLIST \RPARENT}
    \aregla{\PRINT \LPARENT EXPRESSIONLIST \RPARENT}
    \aregla{\LENGTH \LPARENT EXPRESSIONLIST \RPARENT}
  \end{reglas}

\subsubsection{Términos}
  \begin{reglas}
	  \regla{EXPRESSION}{ARRAY}
	  \aregla{REGISTER}
	  \aregla{LBINARYOP}
	  \aregla{EXPRESSION \QUESTION EXPRESSION \COLON LCOMP}
	  \\
    \regla{EXPRESSIONLIST}{EXPRESSION}
    \aregla{EXPRESSION \COMMA EXPRESSIONLIST} 
    \\
	  \regla{LITERAL}{\NUMBER}
    \aregla{\STRING}
    \aregla{\FALSE}
    \aregla{\TRUE}
  \end{reglas}  

\subsubsection{Arreglos}
  \begin{reglas}
    \regla{ARRAY}{\LBRACKET EXPRESSIONLIST \RBRACKET}
    \\
    \regla{ARRAYMEMBER}{VAR \LBRACKET EXPRESSION \RBRACKET}
    \\
    \regla{REGISTER}{\LBRACE REGISTERLIST \RBRACE}
    \\
    \regla{REGISTERLIST}{\ID \COLON EXPRESSION}
    \aregla{\ID \COLON EXPRESSION \COMMA REGISTERLIST}
    \aregla{\LAMBDA}
    \\ 
    \regla{REGISTERMEMBER}{\ID \DOT \ID}
  \end{reglas}  

\subsubsection{Operaciones Binarias}
  \begin{reglas}
    \regla{LBINARYOP}{EXPRESSION \AND LCOMP}
    \aregla{EXPRESSION \OR LCOMP}
    \aregla{LCOMP}
    \\
    \regla{LCOMP}{LCOMP \LEQ BINARYOP}
    \aregla{LCOMP \GEQ BINARYOP}
    \aregla{LCOMP \LT BINARYOP}
    \aregla{LCOMP \GT BINARYOP}
    \aregla{LCOMP \EQUAL BINARYOP}
    \aregla{LCOMP \LNOTEQ BINARYOP}
    \aregla{BINARYOP}
    \\
    \regla{BINARYOP}{BINARYOP \ADD TERM}
    \aregla{BINARYOP \SUB TERM}
    \aregla{TERM}
    \\
    \regla{TERM}{TERM \MULT UNARYOP}
    \aregla{TERM \DIV UNARYOP}
    \aregla{TERM \MOD UNARYOP}
    \aregla{TERM \POW UNARYOP}
    \aregla{UNARYOP}
  \end{reglas}

\subsubsection{Operaciones Unarias}
  \begin{reglas}
    \regla{UNARYMOD}{\INC VAR}
    \aregla{\DEC VAR}
    \aregla{VAR \INC}
    \aregla{VAR \DEC}
    \\
    \regla{UNARYOP}{\ADD UNARYOP}
    \aregla{\SUB UNARYOP}
    \aregla{\NOT UNARYOP}
    \aregla{UNARYMOD}
    \aregla{FACTOR}
    \\
    \regla{VAR}{\ID}
    \aregla{\RES}
    \aregla{ARRAYMEMBER}
    \aregla{REGISTERMEMBER}
    \\
    \regla{FACTOR}{LITERAL}
    \aregla{VAR}
    \aregla{CALL}
    \aregla{\LPARENT EXPRESSION \RPARENT}
  \end{reglas}


\subsection{Expresiones regulares de los tokens}

t\_NEWLINE = r"\textbackslash n+"

t\_NUMBER = r"[0-9]+(\textbackslash.[0-9]+)?" 

t\_STRING = r"\textbackslash"[\^ \textbackslash"]*\textbackslash""

t\_ID = r"[a-zA-Z][a-zA-Z0-9\_]*"

t\_ignore\_WHITESPACES = r"[ \textbackslash t]+"

t\_COMMENT = r"\textbackslash\#.*"

t\_SEMICOLON = r";"

t\_COLON = r":"
 
t\_RBRACE = r"\}"
 
t\_LBRACE = r"\{"

t\_RBRACKET = r"\textbackslash]"
      
t\_LBRACKET = r"\textbackslash["
           
t\_RPARENT = r"\textbackslash)"
             
t\_LPARENT = r"\textbackslash("
              
t\_ADD = r"\textbackslash+"
                
t\_ADDEQ = r"\textbackslash+="
                   
t\_INC = r"\textbackslash+\textbackslash+"
                    
t\_DEC = r"--"
                     
t\_ASSIGN = r"="
                        
t\_EQUAL = r"=="
                          
t\_SUB = r"-"
                           
t\_SUBEQ = r"-="
                               
t\_MULT = r"\textbackslash*"
                                 
t\_MULTEQ = r"\textbackslash*="
                                   
t\_DIV = r"/"
                                     
t\_DIVEQ = r"/="
                                       
t\_POW = r"\textbackslash \^"
                                         
t\_MOD = r"\%"
                                           
t\_LT = r"$<$"
                                            
t\_LEQ = r"$<=$"
                                               
t\_GEQ = r"$>=$"
                                                 
t\_GT = r"$>$"
                                                   
t\_LNOTEQ = r"$!=$"
                                                     
t\_QUESTION = r"\textbackslash?"
                                                      
t\_DOT = r"\textbackslash."
                                                         
t\_COMMA = r","

\subsection{Explicación de la gramática}
La gramática utilizada en trabajo practico es de tipo LALR(Look-Ahead LR
parser), la cual es un tipo de gramatica LR(1) simplificada. Podemos justificar
que nuestra gramatica es LALR, debido a que utilizamos la herramienta de
parseo de python PLY. Esta herramienta genera las tablas de parseo utilizando
el algoritmo LALR que usa YACC, y como no se generan conflictos de tipo
shift/reduce ni de tipo reduce/reduce en esa tabla, podemos afirmar que nuestra
gramática es de tipo LALR.

\subsection{Resolucion de conflictos}
\begin{enumerate}
    
\item Uno de los conflictos que se nos presentó fue al momento de parsear los
operadores ternarios. Por ejemplo para la entrada: e ? e : e + c, el parser
tenia dos derivaciones posibles. En una asociaba el termino de la derecha con
parentesis de la siguiente forma: e ? e : ( e + c ), y en la otra lo hacia
asociando a izquierda : (e ? e : e) + c. \\
Es por esto que decidimos cambiar nuestra regla: 
\\
\begin{reglas}
\regla{TERM}{\LPARENT EXPRESSION \RPARENT \QUESTION EXPRESSION \COLON EXPRESSION}
\\
Por una de la siguiente forma:
\\
\regla{TERM}{EXPRESSION \QUESTION EXPRESSION \COLON LCOMP}
\end{reglas}
Esto permitió que el parser utilize como delimitador cada simbolo no terminal
antes de seguir parseando.

\TODO
\item Otro conflicto que nos presento la gramatica fue el llamado Dangling else
  ......

\item Un conflicto de ambiguedad de la gramatica que se nos presento fue que
  podiamos derivar en un literal de dos formas distintas, ya sea por expresion -> literal
  como por expresion -> binary\_op -> factor -> literal. Es por esto que decidimos cambiar la
  gramatica agregando la regla FACTOR y quitando la produccion EXPRESSION ->
  LITERAL, de la siguiente forma:
  \begin{reglas} 
  \regla{FACTOR}{LITERAL}
  \aregla{\LPARENT EXPRESSION \RPARENT}
  \end{reglas}

\item Otro conflicto que tuvimos fue el de la ambiguedad de los operadores
  binarios y sus conflictos de precedencia. Es por eso que decidimos modificar
  nuestra gramatica, la cual era:

  \begin{reglas}
    \regla{BINARYOP}{TERM \ADD TERM}
    \aregla{TERM \SUB TERM}
    \aregla{TERM \MULT TERM}
    \aregla{TERM \DIV TERM}
    \aregla{TERM \MOD TERM}
    \aregla{TERM \POW TERM}
    \aregla{TERM \AND TERM}
    \aregla{TERM \OR TERM}
    \aregla{TERM \LT TERM}
    \aregla{TERM \LEQ TERM}
    \aregla{TERM \GEQ TERM}
    \aregla{TERM \EQUAL TERM}
    \aregla{TERM \LNOTEQ TERM}
    \\
    Por una modularizada que separa terminos de expresiones y de factores
    permitiendo resolver la ambiguedad presentada, de la siguiente forma:
    \\
    \regla{BINARYOP}{EXPRESSION \ADD TERM}
    \aregla{EXPRESSION \SUB TERM}
    \aregla{TERM}
    \\
    \regla{TERM}{TERM \MULT FACTOR}
    \aregla{TERM \DIV FACTOR}
    \aregla{TERM \DIV FACTOR}
    \aregla{TERM \DIV FACTOR}
    \aregla{TERM \DIV FACTOR}
    \aregla{TERM \DIV FACTOR}
    \\ 
    \regla{FACTOR}{LITERAL}
    \aregla{\LPARENT EXPRESSION \RPARENT}
  \end{reglas}





